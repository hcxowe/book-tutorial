## 使用函数

### 理解函数调用、方法调用、构造函数调用之间的差异

- 方法调用将被查找方法属性的对象作为调用接收者
- 函数调用将全局对象（严格模式下为undefined）作为其接收者
- 构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者

### 熟练掌握高阶函数

- 高阶函数就是那些将函数作为参数或者返回值的函数
- 学会发现可以被高阶函数所取代的常见的编码格式

### 使用call方法自定义接收者来调用方法

- 使用call方法自定义接收者调用函数
- 使用call方法调用给定对象上不存在的方法
- 使用call方法定义高阶函数允许使用者给回调函数指定接收者

### 使用apply方法通过不同数量的参数调用函数

- 与call方法作用一致，call参数分别列出，apply传参使用参数数组

### 使用arguments创建可变参数的函数

- 使用arguments可以实现可变参数的函数

### 永远不要修改arguments对象

- 不要直接修改arguments对象
- 使用数组方法Array.prototype.slice.call(arguments)转换为一个数组在进行操作

### 使用变量保存arguments的引用

- 当心arguments在函数嵌套的覆盖问题

### 使用bind方法提取具有确定接收者的方法

- 提取一个方法不会将方法的接收者绑定到该方法的对象上
- 使用bind方法创建绑定到指定对象的函数

### 使用bind方法实现函数柯里化

- 柯里化：将函数与其参数的一个子集绑定

### 使用闭包而不是字符串来封装代码

- 避免使用eval函数来封装一段代码
- 一些引擎很难优化字符串中的代码
- 接受函数调用的api优于使用eval函数执行字符串的api

### 不要信赖函数对象的toString方法

- 函数的toString方法并没有要求引擎能够精确的返回函数的源代码
- 不同引擎函数调用toString方法可能会返回不同的结果
- 一些系统的方法可能是由其他编程语言实现的，如bind

### 避免使用非标准的栈检查属性

- 避免使用arguments.callee和arguments.caller