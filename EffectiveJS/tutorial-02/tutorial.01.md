## 变量作用域

### 尽量减少使用全局变量

- 创建方式
    - var 显示声明
    - 直接给全局变量添加属性

- 全局变量污染公有的命名空间，导致意外的命名冲突

### 始终声明局部变量

- 始终使用var声明新的局部变量

### 避免使用with

- with(obj) 在运行时动态的在词法作用域头部添加一个新的词法域obj
- with 将在新版ES中被移除
- 使用简短的变量名代替重复访问的对象
- 显示的绑定变量到对象属性上，不要使用with隐式绑定

### 掌握闭包

- 闭包允许引用在当前函数以外定义的变量
- 即是外部函数已经返回，当前函数仍然可以引用外部函数定义的变量
- 闭包可以更新外部函数定义的变量的值

### 理解变量声明提升

- 把变量定义分成两部分：声明 与 赋值
- 声明部分提升值最近的作用域顶部， 赋值部分留在原地
- 重复声明的将会被忽略
- 函数声明提升优先于变量声明提升

### 使用立即调用的函数表达式（IIFE）创建局部作用域

### 当心命名函数表达式的作用域

- 命名函数表达式会绑定到与其函数名相同的变量上，但该变量只作为该函数的一个局部变量
```JavaScript
var obj = function foo() {
      console.log(foo);
};

foo();// foo is not defined
```
- ES3中命名函数表达式作用域会被Object.prototype污染

### 当心局部块函数声明的作用域

- 始终将函数声明置于程序或者被包含的函数的最外层用于避免浏览器兼容问题
- 使用var声明和有条件的赋值语句替代有条件的函数声明

### 避免使用eval创建局部变量

### 间接调用eval函数优于直接调用

- 直接调用会在调用者的作用域中求值
- 间接调用eval会在全局作用域中对eval函数的参数进行求值

```JavaScript
var x = 'g';
function test() {
    var x = 'l';
    return eval('x');
}

test(); // l

function test2() {
    var x = 'l';
    var fex = eval;
    return fex('x');
}

test2(); // g
```



