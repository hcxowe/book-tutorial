## 算法和流程控制
> JavaScript是解释性语言，他无须编译而是将代码以字符串的形式交给js引擎来执行，所以，js代码性能在一定程度上取决于客户端浏览器的js引擎，比如IE低版本明显比不上chrome的js引擎性能

### 循环
- for、while、do-while 循环性能没有差别
- for-in 遍历对象属性，通常用在遍历一个属性未知的对象
- forEach 遍历数组，他传入一个函数处理数组元素，基于函数的迭代比基于循环的迭代慢
- 改善循环性能的最佳方式：减少每次迭代的运算量；减少循环的次数

### switch与if-else
- switch比if-else快
- 判断条件较多时，使用查找表比if-else和switch快

### 递归
- 递归算法可能会导致浏览器栈溢出
- 导致栈溢出，优化递归结束判断条件，使用记忆递归方式，或者改为迭代算法

## 字符串和正则表达式

### 字符串连接
- 使用 '+' 和 '+='
    - IE7-之外的现代浏览器都对其进行了优化，ie7-会为每一个连接的字符串分配内存
    - 使用过程避免创建额外的临时包装对象，如 str += 'one' + 'two'; 会首先创建临时包装对象然后连接'onetwo'，然后临时对象与str连接最后返回给st人；改进方式：str = str + 'one' + 'two';
    - IE8中连接字符串只是记录现有字符串的引用来构造新字符串，当你真正使用该字符串时才真正的创建该字符串
    - 编译器合并:如var str = 'one' + 'two'; 编译合并位 var str = 'onetwo';

- 数组项合并
    - Array.prototype.join 方法可以指定一个连接符连接数组所有项，该方法合并比其他字符串连接方法慢
    - IE7-中，他是优化连接大量字符串唯一的优化方法
    - String.prototype.concat 方法也可以连接字符串，比+= + 慢
    
## 正则表达式
### 正则表达式的工作原理
- 编译：将创建的正则表达式转换为一个原生的代码程序
- 设置起始位置：正则表达式的lastIndex属性作为exec和test方法的起始位置，其他方法位置为字符串的起始位置，这里浏览器会根据具体的正则表达式进行一些查找起始位置的优化
- 匹配每个正则表达式字元：逐个匹配文本与正则表达式，特定字元匹配失败会回溯到之前尝试匹配的位置，使用其他可能的路径尝试匹配
- 匹配成功或者失败

### 回溯
- 如果一个字元匹配失败，则正则表达式将要回到上一个字元进行其他方式的匹配，如果没有其他匹配方式，则在返回上一个字元进行其他方式匹配，直到完全匹配或者失败，匹配成功会很快，而失败会进行反复的匹配回溯过程
- 重复与回溯
- 贪婪量词 * 匹配尽可能的多 
- 惰性量词 *? 匹配尽可能的少

### 回溯失控
- 一些正则表达式在匹配的时候会进行不可估量的回溯次数，导致浏览器假死一段时间
- 嵌套量词： 可以试试 /a+a+b/.test('aaaaaaaaaaaaaaaaaaaaaaa'); 会不会导致浏览器假死，可以简单的修改正则表达式/aa+b/来避免过多的回溯

### 提高正则表达式效率的方法
- 如何让匹配更快的失败
- 正则表达式以简单必须的字元开始：快速找到起始位置
- 使用量词模式，使他们后面的字元互斥
- 减少分支数量，缩小分支范围： [abc] 比 a|b|c更快
- 使用非捕获组: 不关心反向引用时，使用(?...) 替代 (...)
- 只捕获感兴趣的文本以减少后处理
- 暴露必需的字元：如，/^(ab|cd)/  /(^ab|^cd)/
- 使用合适的量词
- 需要重用正则表达式时，使用变量保存
- 将复杂的正则表达式拆分位简单的片段

### 去掉字符串首尾空白符
- str.replace(/^\s+/, '').replace(/\s+$/, '');
- str.replace(/^\s+|\s+$/g, '');
- str.replace(/^\s*([\s\S]*?)\s*$/, '$1');
- str.replace(/^\s*([\s\S]*\S)?\s*$/, '$1');
- str.replace(/^\s*(\S*(\s+\S+)*)\s*$/, '$1');
- 纯字符串方法遍历并去掉首尾空白符
- 结合正则表达式和字符串方法：正则去掉字符串首部空白符，字符串方法遍历去掉尾部空白符