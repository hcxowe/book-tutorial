### 数据的存取位置
- 字面量：代表自身，不存储在特定位置，如数字，字符串，布尔值，null，undefined，函数，对象，数组，正则表达式
- 本地变量：使用var定义的数据存储单元
- 数组元素：存储在js数组内部
- 对象成员：存储在js对象内部

一般的访问速度： 字面量 > 本地变量 > 数组元素 > 对象成员

### 管理作用域
- 全局作用域与函数作用域
- 函数相互嵌套构成作用域链
- 函数在执行时创建执行上下文
- 在执行上下文中从下往上查找变量
- 查找过程将影响性能
- 读取局部变量是最快的，全局变量是最慢的
- js引擎优化会弥补作用域查找变量的性能损失，如：chrome的V8
- 最佳实践：一个跨作用域的值在函数中被引用两次以上，使用局部变量存储

#### 改变作用域链
- with(obj)在执行时会临时改变作用域链，在末尾链式添加一个obj的作用域
- catch(e)在捕获到异常时也会创建一个e的作用域

#### 动态作用域
- eval(),catch(),with()都将创建动态作用域，无法进行静态优化从而影响执行性能

#### 闭包
- 闭包会保留闭包声明时可访问的执行上下文，闭包将增加额外的内存开销

### 对象成员
- 原型
- 原型链
- 遍历原型链搜索属性将增加性能损失
- 嵌套成员，如a.b.c; 没增加一层嵌套都将增加性能损失

### 总结
- 访问字面量与局部变量速度最快，访问数组元素对象属性速度慢
- 局部变量处于作用域的起始位置，访问速度比跨作用域的变量访问速度快，作用域深度越深，访问速度越慢，所以全局变量的访问速度是最慢的
- 避免使用with eval 等会动态创建作用于的语句
- 嵌套的对象成员会明显影响性能
- 属性或者方法在原型链中位置越深，访问速度越慢
- 将会重复引用的数组元素，对象属性，跨作用域，跨原型的变量保存在局部变量中增加访问速度