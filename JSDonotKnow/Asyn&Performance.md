# 异步与性能

## Promise

- 给resolve或reject传递多个参数的话，第一个参数之后的所有参数都会被默默忽略
- 每次你对Promise调用then，它都会创建并返回一个新的Promise， 我们可以把他连接起来实现链式
- 你使用的文字不知会影响你对这些代码的看法，也会影响团队其他开发者对代码的认识
- Promise构造器的第一个参数回调会展开thenable或真正的Promise对象
- reject不会想resolve一样进行展开，reject会原封不动的把值设置为拒绝理由
- `try...catch`无法跨异步操作
- Promise链的一个最佳实践，就是最后总以一个catch结束
- 可信任可组合

## Generator

- 看似同步的异步代码

## 性能

- 在对代码进行测试的时候，应该习惯的一件事就是你所写的代码并不总是引擎真正运行的代码
- 把JS代码看做对引擎要做什么的提示和建议，而不是逐字逐句的要求
- 不要从一个函数到另一个函数传递arguments变量，因为这样的泄漏会降低函数实现速度
- 把`try...catch`分离到单独的函数中，浏览器对任何有`try...catch`的函数实行优化都有一些困难
- 非关键路径上的优化是万恶之源
- 在性能大体相同的几个选择中，可读性应该是另一个重要的考量因素
- 尾调用优化就是一个出现在另一个函数结尾处的函数调用 --- TCO
- Benchmark.js --- 性能测试工具库
- jsPerf.com --- 性能测试比较网站